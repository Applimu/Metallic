use std::rc::Rc;

use crate::{make_program, Atomic, Expr, Program};

// Things to rename:
// Atomic -> Atom
// UnresolvedExpr -> Syntax

/// An Expression which includes no lambdas inside,
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum LambdalessExpr {
    /// Application of a function to a value
    Apply(Rc<LambdalessExpr>, Rc<LambdalessExpr>),
    /// An atomic value in our expression
    Atom(Atomic),
    /// A match statement which matches on an enum of a specific type
    Match {
        enum_name: String,
        matchend: Rc<LambdalessExpr>,
        branches: Vec<LambdalessExpr>,
    },
    /// A let expression with
    Let {
        new_value_type: Rc<LambdalessExpr>,
        new_value: Rc<LambdalessExpr>,
        expr: Rc<LambdalessExpr>,
    },
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DefuncdDef {
    /// A list of all the functions curried type inputs
    input_types: Vec<LambdalessExpr>,
    code: LambdalessExpr
}

#[derive(Debug)]
pub struct LiftedProgram {
    global_names: Vec<String>,
    globals: Vec<DefuncdDef>, 
    evals: Vec<LambdalessExpr>,
}

struct GlobalIdGenerator(usize, Vec<usize>);

impl GlobalIdGenerator {
    fn generate(&mut self) -> usize {
        let i = self.0;
        self.0 += 1;
        i
    }

    fn register(&mut self, old: usize) -> usize {
        let new = self.0;
        self.0 += 1;
        self.1.insert(old, new);
        new
    }

    fn into_new(&self, old: usize) -> usize {
        self.1[old]
    }
}

/// Lifts an expression into a global variable, returning its global id and all the other expressions that
/// were recursively lifted
fn lift_as_global(mut expr: &Expr, mut local_var_types: Vec<LambdalessExpr>, gids: &mut GlobalIdGenerator) -> Vec<DefuncdDef> {
    let mut input_types = vec![];
    while let Expr::Function {input_type, output} = expr {
        input_types.push(input_type.clone());
        expr = output.as_ref();
    }
    // atp output is guarenteed to NOT be an Expr::Function and so we have
    // determined all of the inputs to this curried function
    // Now we convert our array of input type Exprs [X1, X2, X3, ...]
    // into LambdalessExprs
    let mut lambdas = Vec::new();
    let mut type_exprs = Vec::new();
    for input_type in input_types {
        let (type_expr, mut new_lambdas) = lift_expr(input_type.as_ref(), local_var_types.clone(), gids);
        type_exprs.push(type_expr);
        lambdas.append(&mut new_lambdas);
    }
    // add our new locals to our list of captured variables
    local_var_types.append(&mut type_exprs);
    // TODO: Optimize so that we only capture the local variables that are actually
    // used in the expression.
    let (out_expr, mut more_lambdas) = lift_expr(expr, local_var_types.clone(), gids);
    // for (i ,_) in local_var_types.iter().enumerate() {
    //     out_expr = LambdalessExpr::Apply(Rc::new(out_expr), Rc::new(LambdalessExpr::Atom(Atomic::Local(i))));
    // }
    lambdas.insert(0, DefuncdDef { input_types: local_var_types, code: out_expr });
    lambdas.append(&mut more_lambdas);
    lambdas
}

/// Lifts all of the lambdas in an expression, creating a lambdaless expression, along with all of the
/// parts of the expression that have previously been lifted
fn lift_expr(expr: &Expr, mut local_var_types: Vec<LambdalessExpr>, gids: &mut GlobalIdGenerator) -> (LambdalessExpr, Vec<DefuncdDef>) {
    // it is VERY IMPORTANT that expressions are added to globals in the order that they are
    // generated by gid.generate()  !!!
    match expr {
        Expr::Apply(e1, e2) => {
            let (le1, mut new_lambdas1) = lift_expr(e1.as_ref(), local_var_types.clone(), gids);
            let (le2, mut new_lambdas2) = lift_expr(e2.as_ref(), local_var_types, gids);
            new_lambdas1.append(&mut new_lambdas2);
            (LambdalessExpr::Apply(Rc::new(le1), Rc::new(le2)), new_lambdas1)
        },
        Expr::Function { input_type: _, output: _ } => {
            let id = gids.generate();
            let lambdas = lift_as_global(expr, local_var_types.clone(), gids);
            let mut out = LambdalessExpr::Atom(Atomic::Global(id));
            for (i, _) in local_var_types.iter().enumerate() {
                out = LambdalessExpr::Apply(Rc::new(out), Rc::new(LambdalessExpr::Atom(Atomic::Local(i))))
            }
            (out, lambdas)
        },
        Expr::Atom(Atomic::Global(old)) => {
            (LambdalessExpr::Atom(Atomic::Global(gids.into_new(*old))), Vec::new())
        },
        Expr::Atom(atom) => (LambdalessExpr::Atom(atom.clone()), Vec::new()),
        Expr::Match { enum_name, matchend, branches } => {
            let (matchendl, mut lambdas) = lift_expr(matchend, local_var_types.clone(), gids);
            let mut branchles = Vec::new();
            for e in branches.iter() {
                let (el, mut more_lambdas) = lift_expr(e, local_var_types.clone(), gids);
                branchles.push(el);
                lambdas.append(&mut more_lambdas);
            }
            
            (
                LambdalessExpr::Match { enum_name: enum_name.clone(), matchend: Rc::new(matchendl), branches: branchles },
                lambdas
            )
            
        },
        Expr::Let { new_value_type, new_value, expr } => {
            let (new_value_typel, mut lambdas) = lift_expr(&new_value_type, local_var_types.clone(), gids);
            let (new_value1, mut lambdas2) = lift_expr(new_value, local_var_types.clone(), gids);
            lambdas.append(&mut lambdas2);
            local_var_types.push(new_value_typel.clone());
            let (exprl, mut lambdas3) = lift_expr(expr, local_var_types, gids);
            lambdas.append(&mut lambdas3);
            (LambdalessExpr::Let{
                new_value_type: Rc::new(new_value_typel),
                new_value: Rc::new(new_value1),
                expr: Rc::new(exprl),
            }, lambdas)
        },
    }
}

pub fn lift_lambdas(prog: &Program) -> LiftedProgram {
    // this stores where each global in the input goes in the output
    // let mut globals_map: Vec<usize> = Vec::new();
    let mut result = LiftedProgram {
        global_names: Vec::new(),
        globals: Vec::new(),
        evals: Vec::new(),
    };
    let mut ids = GlobalIdGenerator(0, Vec::new());
    for i in 0..prog.names.len() {
        let lambdaful_expr = prog.globals[i].as_ref();
        let new_id = ids.register(i);
        let mut new_lambdas = lift_as_global(lambdaful_expr, Vec::new(), &mut ids);
        // bind this global id to it's old one
        assert!(result.globals.len() == new_id);
        result.globals.append(&mut new_lambdas);
    }
    result
} 

pub fn main() {
    let file_str =
        r#"
            enum That  a b c
            
            def fun That (fun Int (fun Int Int)): this := fn That : f do fn Int: g do
                match f
                    case a do fn Int : x do add g 1
                    case b do fn Int : y do add g 2
                    case c do fn Int : z do add g 3
                end

            def DepProd Type fn Type: T do DepProd Type fn Type: U do fun (fun T U) (fun (PairType Int T) (PairType Int U)):
            map_prod := fn Type: T do fn Type: U do fn fun T U: f do
                fn PairType Int T: input do
                pair (first input) (f (second input))
        "#;
    let prog = make_program(file_str).expect("Parsing error");

    let result = lift_lambdas(&prog);
    for (i, d) in result.globals.iter().enumerate() {
        println!("\n\n#{}: {:?}", i, d);
    }
}

