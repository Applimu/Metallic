use std::{collections::HashMap, rc::Rc};

use crate::{make_program, Atomic, Expr, Program};

// Things to rename:
// Atomic -> Atom
// UnresolvedExpr -> Syntax


// TODO: Consider if a bottom-up approach to lifting lambda expressions would work better
// than a top-down approach? Mostly so that we wouldn't have to be doing weird indexing stuff
// from returning all of the recursive definitions. Like we would only consider lifting expressions where
// all of the internal-values are already lifted.

/// An Expression which includes no lambda expressions inside.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LambdalessExpr {
    /// Application of a function to a value
    Apply(Rc<LambdalessExpr>, Rc<LambdalessExpr>),
    /// An atomic value in our expression
    Atom(Atomic),
    /// A match statement which matches on an enum of a specific type
    Match {
        enum_name: String,
        matchend: Rc<LambdalessExpr>,
        branches: Vec<LambdalessExpr>,
    },
    /// A let expression
    Let {
        new_value_type: Rc<LambdalessExpr>,
        new_value: Rc<LambdalessExpr>,
        expr: Rc<LambdalessExpr>,
    },
}

/// A definition of a function. Contains a list of the types
/// of all of it's arguments (which are curried) and the code to be executed with
/// all of those free variables in scope.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DefuncdDef {
    /// A list of all the functions curried type inputs
    input_types: Vec<LambdalessExpr>,
    code: LambdalessExpr
}

/// A Program where all of the lambda expressions have been lifted out to new
/// global definitions.
#[derive(Debug)]
pub struct LiftedProgram {
    global_names: Vec<String>,
    globals: Vec<DefuncdDef>, 
    evals: Vec<LambdalessExpr>,
}

/// A singleton pattern which keeps track of all of the Ids that have been generated
/// for a program.
struct GlobalIdGenerator(usize, Vec<usize>);

impl GlobalIdGenerator {
    /// Generate a fresh new global Id
    fn generate(&mut self) -> usize {
        let i = self.0;
        self.0 += 1;
        i
    }

    /// I honestly do not know what this does rn
    fn register(&mut self, old: usize) -> usize {
        let new = self.0;
        self.0 += 1;
        self.1.insert(old, new);
        new
    }

    /// I honestly do not know what this does rn
    fn into_new(&self, old: usize) -> usize {
        self.1[old]
    }
}

/// Lifts an expression into a global variable, returning its global id and all the other expressions that
/// were recursively lifted
fn lift_as_global(mut expr: &Expr, mut local_var_types: Vec<LambdalessExpr>, gids: &mut GlobalIdGenerator) -> Vec<DefuncdDef> {
    // First if `expr` is an `Expr::Function`, we need to collect all of the free variables'
    // types and then move into the inner expression.
    let mut input_types = vec![];
    while let Expr::Function {input_type, output} = expr {
        input_types.push(input_type.clone());
        expr = output.as_ref();
    }
    // create our list of possible inside expressions that were lifted.
    let mut lambdas = Vec::new();

    // Now we lift all of the lambdas that are inside the array of the free variables' types
    let mut lifted_type_exprs = Vec::new();
    for input_type in input_types {
        let (type_expr, mut new_lambdas) = lift_expr(input_type.as_ref(), local_var_types.clone(), gids);
        lifted_type_exprs.push(type_expr);
        lambdas.append(&mut new_lambdas);
    }
    // add our new locals to our list of captured variables
    local_var_types.append(&mut lifted_type_exprs);
    // TODO: Optimize so that we only capture the local variables that are actually
    // used in the expression.
    let (out_expr, mut more_lambdas) = lift_expr(expr, local_var_types.clone(), gids);
    // for (i ,_) in local_var_types.iter().enumerate() {
    //     out_expr = LambdalessExpr::Apply(Rc::new(out_expr), Rc::new(LambdalessExpr::Atom(Atomic::Local(i))));
    // }
    lambdas.insert(0, DefuncdDef { input_types: local_var_types, code: out_expr });
    lambdas.append(&mut more_lambdas);
    lambdas
}

/// Lifts all of the lambdas in an expression. Returns the expression converted into a `LamdalessExpr`, and returns
/// a `Vec` of all of the extra lambda functions that were recursively liften when lifting the expression.
fn lift_expr(expr: &Expr, mut local_var_types: Vec<LambdalessExpr>, gids: &mut GlobalIdGenerator) -> (LambdalessExpr, Vec<DefuncdDef>) {
    // it is VERY IMPORTANT that expressions are added to globals in the order that they are
    // generated by gid.generate()  !!!
    match expr {
        Expr::Apply(e1, e2) => {
            let (le1, mut new_lambdas1) = lift_expr(e1.as_ref(), local_var_types.clone(), gids);
            let (le2, mut new_lambdas2) = lift_expr(e2.as_ref(), local_var_types, gids);
            new_lambdas1.append(&mut new_lambdas2);
            (LambdalessExpr::Apply(Rc::new(le1), Rc::new(le2)), new_lambdas1)
        },
        Expr::Function { input_type: _, output: _ } => {
            let id = gids.generate();
            let lambdas = lift_as_global(expr, local_var_types.clone(), gids);
            let mut out = LambdalessExpr::Atom(Atomic::Global(id));
            for (i, _) in local_var_types.iter().enumerate() {
                out = LambdalessExpr::Apply(Rc::new(out), Rc::new(LambdalessExpr::Atom(Atomic::Local(i))))
            }
            (out, lambdas)
        },
        Expr::Atom(Atomic::Global(old)) => {
            (LambdalessExpr::Atom(Atomic::Global(gids.into_new(*old))), Vec::new())
        },
        Expr::Atom(atom) => (LambdalessExpr::Atom(atom.clone()), Vec::new()),
        Expr::Match { enum_name, matchend, branches } => {
            let (lifted_matchend, mut lambdas) = lift_expr(matchend, local_var_types.clone(), gids);
            let mut lifted_branches = Vec::new();
            for e in branches.iter() {
                let (el, mut more_lambdas) = lift_expr(e, local_var_types.clone(), gids);
                lifted_branches.push(el);
                lambdas.append(&mut more_lambdas);
            }
            
            (
                LambdalessExpr::Match { enum_name: enum_name.clone(), matchend: Rc::new(lifted_matchend), branches: lifted_branches },
                lambdas
            )
            
        },
        Expr::Let { new_value_type, new_value, expr } => {
            let (new_value_typel, mut lambdas) = lift_expr(&new_value_type, local_var_types.clone(), gids);
            let (new_value1, mut lambdas2) = lift_expr(new_value, local_var_types.clone(), gids);
            lambdas.append(&mut lambdas2);
            local_var_types.push(new_value_typel.clone());
            let (exprl, mut lambdas3) = lift_expr(expr, local_var_types, gids);
            lambdas.append(&mut lambdas3);
            (LambdalessExpr::Let{
                new_value_type: Rc::new(new_value_typel),
                new_value: Rc::new(new_value1),
                expr: Rc::new(exprl),
            }, lambdas)
        },
    }
}

/// Takes a reference to a program and constructs a `LiftedProgram` which (ideally) has
/// the same functionality
pub fn lift_lambdas(prog: &Program) -> LiftedProgram {
    // this stores where each global in the input goes in the output
    // let mut globals_map: Vec<usize> = Vec::new();
    let mut lifted = LiftedProgram {
        global_names: Vec::new(),
        globals: Vec::new(),
        evals: Vec::new(),
    };
    let mut ids = GlobalIdGenerator(0, Vec::new());
    for i in 0..prog.len() {
        let lambdaful_expr = prog.globals[i].as_ref();
        let new_id = ids.register(i);
        let mut new_lambdas = lift_as_global(lambdaful_expr, Vec::new(), &mut ids);
        // bind this global id to it's old one
        assert!(lifted.globals.len() == new_id);
        lifted.globals.append(&mut new_lambdas);
    }

    for eval in prog.evals.iter() {
        let (lifted_eval, mut new_lambdas) = lift_expr(eval, Vec::new(), &mut ids);
        lifted.globals.append(&mut new_lambdas);
        lifted.evals.push(lifted_eval);

    }
    lifted
} 

/*
A program is *defunctionalized* if all higher order functions are removed
*/
/// Returns a list of indices into the provided `LiftedProgram` paired with the
/// argument indices into their definitions that are functions.
fn find_higher_order_args(prog: &LiftedProgram) -> HashMap<LambdalessExpr, Vec<(usize, usize)>> {
    let mut higher_order_args : HashMap<LambdalessExpr, Vec<(usize, usize)>> = HashMap::new();
    for i in 0..prog.globals.len() {
        for (j, arg_type) in prog.globals[i].input_types.iter().enumerate() {
            todo!()
        }
    }
    higher_order_args
}



pub fn main() {
    let file_str =
        r#"
            enum That  a b c
            
            def fun That (fun Int (fun Int Int)): this := fn That : f do fn Int: g do
                match f
                    case a do fn Int : x do add g 1
                    case b do fn Int : y do add g 2
                    case c do fn Int : z do add g 3
                end

            def DepProd Type fn Type: T do DepProd Type fn Type: U do fun (fun T U) (fun (PairType Int T) (PairType Int U)):
            map_prod := fn Type: T do fn Type: U do fn fun T U: f do
                fn PairType Int T: input do
                pair (first input) (f (second input))

            eval add 3 5
            eval (fn Type: T do add 6) Int 9
        "#;
    let prog = make_program(file_str).expect("Parsing error");

    let result = lift_lambdas(&prog);
    for (i, d) in result.globals.iter().enumerate() {
        println!("\n\n#{}: {:?}", i, d);
    }
}

